name: Build, Push and Deploy to EC2

on:
  push:
    branches: [ main, finalv2 ]  # Change to your main branch name if different

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
      
      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
      
      - name: Build and push Frontend
        uses: docker/build-push-action@v4
        with:
          context: ./Frontend
          push: true
          tags: ${{ secrets.DOCKER_USERNAME }}/school-frontend:latest
          build-args: |
            VITE_API_URL=https://${{ secrets.DOMAIN_NAME }}/api
      
      - name: Build and push Backend
        uses: docker/build-push-action@v4
        with:
          context: ./Backend
          push: true
          tags: ${{ secrets.DOCKER_USERNAME }}/school-backend:latest

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    steps:
      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.7.0
        with:
          ssh-private-key: ${{ secrets.AWS_SSH_KEY }}
      
      - name: Add server to known hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ secrets.AWS_EC2_HOST }} >> ~/.ssh/known_hosts
      
      - name: Deploy to EC2
        run: |
          # Create deployment script on EC2
          ssh ${{ secrets.AWS_EC2_USERNAME }}@${{ secrets.AWS_EC2_HOST }} << 'EOF'
          # Create app directory if it doesn't exist
          mkdir -p ~/app
          mkdir -p ~/app/nginx
          mkdir -p ~/app/certbot/conf
          mkdir -p ~/app/certbot/www
          
          # Create docker-compose file
          cat > ~/app/docker-compose.yml << 'EOL'
          services:
            nginx:
              image: nginx:alpine
              ports:
                - "80:80"
                - "443:443"
              restart: always
              volumes:
                - ./nginx:/etc/nginx/conf.d
                - ./certbot/conf:/etc/letsencrypt
                - ./certbot/www:/var/www/certbot
              depends_on:
                - frontend
                - backend
            
            frontend:
              image: ${{ secrets.DOCKER_USERNAME }}/school-frontend:latest
              restart: always
              environment:
                - NODE_ENV=production
                - VITE_API_URL=https://${{ secrets.DOMAIN_NAME }}/api
              depends_on:
                - backend
            
            backend:
              image: ${{ secrets.DOCKER_USERNAME }}/school-backend:latest
              restart: always
              environment:
                - MONGO_URI=${MONGO_URI}
                - JWT_SECRET=${JWT_SECRET}
                - CLOUDINARY_CLOUD_NAME=${CLOUD_NAME}
                - CLOUDINARY_API_KEY=${CLOUDINARY_API_KEY}
                - CLOUDINARY_API_SECRET=${CLOUDINARY_API_SECRET}
                - EMAIL_USER=${EMAIL_USER}
                - EMAIL_PASS=${EMAIL_PASS}
                - FRONTEND_URL=https://${{ secrets.DOMAIN_NAME }}
                - LOGO_URL=${LOGO_URL}
                - LEAD_PDF_URL=${LEAD_PDF_URL}
                - LEAD_VIDEO_URL=${LEAD_VIDEO_URL}
                - TEAM_MEMBER_PDF_URL=${TEAM_MEMBER_PDF_URL}
                - TEAM_MEMBER_VIDEO_URL=${TEAM_MEMBER_VIDEO_URL}
                - SUPPORT_EMAIL=${SUPPORT_EMAIL}
          
            certbot:
              image: certbot/certbot
              volumes:
                - ./certbot/conf:/etc/letsencrypt
                - ./certbot/www:/var/www/certbot
              entrypoint: "/bin/sh -c 'trap exit TERM; while :; do certbot renew; sleep 12h & wait $${!}; done;'"
          
          networks:
            default:
              name: school-network
          EOL
          
          # Create env file
          cat > ~/app/.env << 'EOL'
          MONGO_URI=${{ secrets.MONGO_URI }}
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          CLOUD_NAME=${{ secrets.CLOUD_NAME }}
          CLOUDINARY_API_KEY=${{ secrets.CLOUDINARY_API_KEY }}
          CLOUDINARY_API_SECRET=${{ secrets.CLOUDINARY_API_SECRET }}
          EMAIL_USER=${{ secrets.EMAIL_USER }}
          EMAIL_PASS=${{ secrets.EMAIL_PASS }}
          FRONTEND_URL=https://${{ secrets.DOMAIN_NAME }}
          LOGO_URL=${{ secrets.LOGO_URL }}
          LEAD_PDF_URL=${{ secrets.LEAD_PDF_URL }}
          LEAD_VIDEO_URL=${{ secrets.LEAD_VIDEO_URL }}
          TEAM_MEMBER_PDF_URL=${{ secrets.TEAM_MEMBER_PDF_URL }}
          TEAM_MEMBER_VIDEO_URL=${{ secrets.TEAM_MEMBER_VIDEO_URL }}
          SUPPORT_EMAIL=${{ secrets.SUPPORT_EMAIL }}
          EOL
          
          # Create initial nginx config for certificate validation
          cat > ~/app/nginx/init.conf << 'EOL'
          server {
              listen 80;
              server_name ${{ secrets.DOMAIN_NAME }};
              
              location /.well-known/acme-challenge/ {
                  root /var/www/certbot;
              }
              
              location / {
                  return 200 'Ready for Let\'s Encrypt validation';
              }
          }
          EOL
          
          # Create an initial compose file just for certificate validation
          cat > ~/app/init-compose.yml << 'EOL'
          services:
            nginx:
              image: nginx:alpine
              ports:
                - "80:80"
              volumes:
                - ./nginx/init.conf:/etc/nginx/conf.d/default.conf
                - ./certbot/www:/var/www/certbot
          EOL
          
          # Stop any running containers
          cd ~/app
          docker-compose down || true
          
          # Start initial nginx container for certificate validation
          docker-compose -f init-compose.yml up -d
          
          # Wait for nginx to start
          sleep 5
          
          # Obtain the certificate
          docker run --rm -v "$(pwd)/certbot/conf:/etc/letsencrypt" -v "$(pwd)/certbot/www:/var/www/certbot" \
            certbot/certbot certonly --webroot --webroot-path=/var/www/certbot \
            --email ${{ secrets.SUPPORT_EMAIL }} --agree-tos --no-eff-email \
            -d ${{ secrets.DOMAIN_NAME }}
          
          # Stop the initial nginx
          docker-compose -f init-compose.yml down
          
          # Create final nginx config
          cat > ~/app/nginx/default.conf << 'EOL'
          server {
              listen 80;
              server_name ${{ secrets.DOMAIN_NAME }};
              
              location /.well-known/acme-challenge/ {
                  root /var/www/certbot;
              }
              
              location / {
                  return 301 https://$host$request_uri;
              }
          }
          
          server {
              listen 443 ssl;
              server_name ${{ secrets.DOMAIN_NAME }};
              
              ssl_certificate /etc/letsencrypt/live/${{ secrets.DOMAIN_NAME }}/fullchain.pem;
              ssl_certificate_key /etc/letsencrypt/live/${{ secrets.DOMAIN_NAME }}/privkey.pem;
              
              location / {
                  proxy_pass http://frontend;
                  proxy_set_header Host $host;
                  proxy_set_header X-Real-IP $remote_addr;
                  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto $scheme;
              }
              
              location /api/ {
                  proxy_pass http://backend:5000/api/;
                  proxy_http_version 1.1;
                  proxy_set_header Upgrade $http_upgrade;
                  proxy_set_header Connection 'upgrade';
                  proxy_set_header Host $host;
                  proxy_cache_bypass $http_upgrade;
              }
          }
          EOL
          
          # Log into Docker Hub
          docker login -u ${{ secrets.DOCKER_USERNAME }} -p ${{ secrets.DOCKER_PASSWORD }}
          
          # Pull latest images and start all containers
          docker-compose pull
          docker-compose up -d
          EOF